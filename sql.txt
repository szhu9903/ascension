选择 ：select * from table where 范围

插入 ：insert into table(field1,field2) value(value1,value2)

删除 ：delete from table where 范围

更新 ：update table set field1=value1 where 范围

查找 ：select * from table where field1 like '%value1%'

排序 ：select * from table order by field1,field2 [desc]
asc 按升序排列
desc 按降序排列

分页 ：select name from table order by id desc limit 3 offset 0 (倒序，结果集分页，取三条数据，从0开始索引) 
LIMIT总是设定为pageSize；
OFFSET计算公式为pageSize * (pageIndex - 1)。

总数 ：select count as totalcount from table1

求和：select sum(field1) as sumvalue from table1

平均：select avg(field1) as avgvalue from table1

最大：select max(field1) as maxvalue from table1

最小：select min(field1) as minvalue from table1


时间格式 ：to_char(t1.create_date AT TIME ZONE 'Etc/GMT+8','YYYY-MM-DD HH:MM:SS') as create_date

多表查询 ：from oz_th_repair t1 left join oz_th_dict t2 on t2.flabel = t1.frepair_type
left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

分组 ：GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组

复制表数据：insert into student(name,age) select name,age from student  （将查询出来的数据插入表中）



-- 数据库优化查询
-- 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。
建立索引的原则：

1) 定义主键的数据列一定要建立索引。

2) 定义有外键的数据列一定要建立索引。

3) 对于经常查询的数据列最好建立索引。

4) 对于需要在指定范围内的快速或频繁查询的数据列;

5) 经常用在WHERE子句中的数据列。

6) 经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。

7) 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8) 对于定义为text、image和bit的数据类型的列不要建立索引。

9) 对于经常存取的列避免建立索引 

9) 限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。

10) 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。

建立索引：[唯一索引，全文索引，空间索引]
    create [UNIQUE|FULLTEXT|SPATIAL] index index_name 
    [USING index]
    index_name : 自定义的索引的名称

















-- distinct 显示记录不重复
SELECT DISTINCT
	ffood_name 
FROM
	oz_th_food
	
	
-- 处理null，默认'0':
COALESCE(fdish_greens,'0') as fish_greens


-- 当查询到空值默认设置为‘0’
SELECT
	ffood_num,
	ffood_name,
CASE  WHEN fdish_meat2 = '' THEN '0' 
ELSE fdish_meat
	END

FROM
	oz_th_food
	
	
	
	-- having对分组查询数据使用聚合函数筛选
	
SELECT
	ffood_time_type,
	avg( fprice ) 
FROM
	oz_th_food 
GROUP BY
	ffood_time_type 
HAVING
	avg( fprice ) <3



-- string对分组的某个字段所有值显示，例如，一个房间所有的职工

SELECT
	l.ffloor_num,
	r.froom_num,
	string_agg ( r.fcheck_in_person_name,',' ) as check_name
FROM
	oz_th_check_in_record AS r
	LEFT JOIN oz_th_room AS l ON r.froom_num = l.froom_num 
WHERE
	r.fdel_flag = '0' 
GROUP BY
	l.ffloor_num,r.froom_num 
ORDER BY
	r.froom_num ASC



-- 时间转换

SELECT create_date,to_char(create_date,'YYYY-MM-DD') as dates from   oz_th_cost_detail


-- sqlserver 分页

select top 10 * from person 
where id not in(
select top 40 id from person order by id
) order by id

-- sql 存储过程




















































